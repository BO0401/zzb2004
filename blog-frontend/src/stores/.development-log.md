# Stores 状态管理开发日志

## Store结构
- `app.ts` - 应用全局状态管理
  - 主题状态 (theme)
  - 移动端检测 (isMobile)
  - 侧边栏状态 (sidebarCollapsed)

## 问题记录与解决方案

### 问题1：主题状态持久化
**问题**：用户刷新页面后主题设置丢失
**解决方案**：
```typescript
// 初始化时读取localStorage
const initTheme = () => {
  const savedTheme = localStorage.getItem('theme')
  if (savedTheme) {
    theme.value = savedTheme as 'light' | 'dark'
  } else {
    theme.value = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light'
  }
}

// 监听变化自动保存
watch(theme, (newValue) => {
  localStorage.setItem('theme', newValue)
}, { immediate: true })
```
**改进**：实现主题状态的自动持久化

### 问题2：响应式检测性能
**问题**：频繁的resize事件影响性能
**解决方案**：
```typescript
const checkMobile = () => {
  isMobile.value = window.innerWidth < 768
}

// 添加防抖处理
const debouncedCheck = debounce(checkMobile, 100)
window.addEventListener('resize', debouncedCheck)
```
**改进**：使用防抖优化resize事件处理

## app.ts Store 的设计思路

### 状态设计的原则

```typescript
// 状态应该是最小化的、可预测的、易于调试的
export const useAppStore = defineStore('app', () => {
  // 主题状态 - 影响整个应用的视觉呈现
  const theme = ref<'light' | 'dark'>('light')
  
  // 移动端状态 - 影响布局和交互方式
  const isMobile = ref(false)
  
  // 侧边栏状态 - 控制导航的显示隐藏
  const sidebarCollapsed = ref(false)
})
```

**设计哲学**: "每一个状态都应该有存在的理由，每一个状态的变化都应该是可追踪的。"

### 主题管理的深度思考

#### 为什么需要主题管理？
**用户需求分析**:
- **个性化体验** - 用户希望根据喜好选择主题
- **护眼需求** - 暗黑模式在夜间阅读更舒适
- **系统一致性** - 跟随系统主题设置

#### 实现思路
```typescript
const toggleTheme = () => {
  theme.value = theme.value === 'light' ? 'dark' : 'light'
  
  // 同步到 DOM
  document.documentElement.setAttribute('data-theme', theme.value)
  
  // 持久化存储
  localStorage.setItem('theme', theme.value)
  
  // 通知 Element Plus
  if (theme.value === 'dark') {
    document.documentElement.classList.add('dark')
  } else {
    document.documentElement.classList.remove('dark')
  }
}
```

**技术细节的考虑**:
1. **DOM 操作** - 直接操作 DOM 来应用主题
2. **持久化** - 用户的选择应该被记住
3. **组件库集成** - 与 Element Plus 的主题系统集成

**心理过程**: "主题切换看似简单，但要做好需要考虑很多细节。用户点击切换按钮的那一刻，他们期望的是即时、流畅、一致的体验。"

### 响应式检测的实现

```typescript
const checkMobile = () => {
  isMobile.value = window.innerWidth < 768
}

// 监听窗口大小变化
const initMobileDetection = () => {
  checkMobile()
  window.addEventListener('resize', checkMobile)
}
```

**设计考虑**:
- **阈值选择** - 768px 是经典的移动端断点
- **性能优化** - 避免频繁的重新计算
- **内存管理** - 记得清理事件监听器

**反思**: "响应式设计不仅仅是 CSS 的事情，JavaScript 状态管理也需要感知设备类型。"

### 侧边栏状态管理

```typescript
const toggleSidebar = () => {
  sidebarCollapsed.value = !sidebarCollapsed.value
}

const closeSidebar = () => {
  sidebarCollapsed.value = true
}
```

**使用场景分析**:
- **桌面端** - 侧边栏可以固定显示
- **移动端** - 侧边栏需要可收起，节省屏幕空间
- **用户习惯** - 有些用户喜欢更宽的阅读区域

## 开发过程中的挑战

### 挑战1：状态的初始化时机
**问题描述**: "什么时候初始化状态？在哪里调用初始化函数？"

**解决思路**:
```typescript
// 在 main.ts 中初始化
const app = createApp(App)
const pinia = createPinia()
app.use(pinia)

// 在 App.vue 中调用初始化
const appStore = useAppStore()
onMounted(() => {
  appStore.initTheme()
  appStore.initMobileDetection()
})
```

**心理过程**: "状态管理的初始化就像房子的地基，必须在一切开始之前就打好。"

### 挑战2：状态的持久化
**技术选择**: localStorage vs sessionStorage vs IndexedDB

**分析过程**:
- **localStorage** - 持久存储，适合用户偏好设置
- **sessionStorage** - 会话存储，适合临时状态
- **IndexedDB** - 复杂数据，这个项目暂时不需要

**最终方案**:
```typescript
const initTheme = () => {
  const savedTheme = localStorage.getItem('theme') as 'light' | 'dark'
  if (savedTheme) {
    theme.value = savedTheme
  } else {
    // 检测系统主题偏好
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
    theme.value = prefersDark ? 'dark' : 'light'
  }
  
  // 应用主题
  document.documentElement.setAttribute('data-theme', theme.value)
}
```

**设计亮点**: "不仅要记住用户的选择，还要智能地检测系统偏好。这是对用户体验的深度思考。"

### 挑战3：状态的响应式更新
**问题**: "如何确保状态变化时，所有相关组件都能及时更新？"

**Pinia 的优势**:
```typescript
// 在任何组件中
const appStore = useAppStore()

// 自动响应式
watchEffect(() => {
  console.log('主题变化了:', appStore.theme)
})

// 计算属性也是响应式的
const isDark = computed(() => appStore.theme === 'dark')
```

### 问题3：状态初始化顺序
**问题**：状态初始化时机不当导致错误
**解决方案**：
```typescript
// 确保在组件挂载后初始化
const initializeApp = () => {
  initTheme()
  initMobileDetection()
}

// 在App.vue中调用
onMounted(() => {
  appStore.initializeApp()
})
```
**改进**：统一管理状态初始化流程

### 问题4：状态变化监听
**问题**：需要在状态变化时执行副作用操作
**解决方案**：
```typescript
// 监听主题变化，更新DOM
watch(theme, (newTheme) => {
  document.documentElement.setAttribute('data-theme', newTheme)
  localStorage.setItem('theme', newTheme)
}, { immediate: true })
```
**改进**：使用watch监听状态变化并执行相应操作

### 问题5：状态类型定义
**问题**：状态类型不够严格，容易出现类型错误
**解决方案**：
```typescript
interface AppState {
  theme: 'light' | 'dark'
  isMobile: boolean
  sidebarCollapsed: boolean
}
```
**改进**：定义严格的状态类型接口